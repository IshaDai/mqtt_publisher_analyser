# MQTT Publisher and Analyser
## 1 Introduction
MQTT is the most common open IoT protocol being deployed today. It provides a publisher/subscriber model, using a broker or server. It allows for an almost-unbounded number of sources to publish information, each at their own rate, and subscribers to receive information (and act on it). As such, it is designed to provide high-performance communication mechanisms, with minimal delays and excellent scaling performance. We’ll use it to monitor the performance of some imaginary system: say counting the total kilograms of minerals rushing by on a conveyor belt, that you can control. This assignment will look at the functionality and performance of the publishers, brokers, the network and the subscribers.

This is a coding, analysis and writing assignment. You may code in any programming language (hope that’s enough for everyone), and yes, you may use MQTT and other helper libraries. The assessment will not rely solely on running on your code, but more on the data gathering and your analysis. However we will review the code and may briefly test it against our own broker running in the usual lab-type environments or similar. You will need to identify in your code any libraries you are using.

## Instruction 
You need to write three small programs, the first two of which could be combined into one:
• A Publisher: It will send a simple message to the broker, an incrementing counter (e.g. 0, 1, 2, 3, ...). It will send those messages at a specific QoS level (0, 1 or 2), and with a specific delay between messages (0ms, 10ms, 20ms, 50ms, 100ms, 500ms). It needs to publish to the topic ‘counter/<qos>/<delay>’, so e.g. ‘counter/1/100’ implies qos=1 and delay=100. It should only publish one stream at any given time, based on input from the Controller.
• A Controller: This will listen to the broker on two topics ‘request/qos’ and ‘request/delay’. Whenever it gets a message on either of them it needs to modify the Publisher’s behaviour accordingly. One way is to stop any current publisher process (e.g. send a KILL signal, or at worst put a 2.5-minute time limit on it running) and start a new one with the new parameters, say via command line arguments. Another approach might be through event-handling and multi-threading, but it is up to you. Please explain in a README file or comments what approach you are taking.
• An Analyser: This will listen to the counter on the broker and take measurements (below) to report statistics on the performance of the broker/publisher/network combination. Those measurements should be taken across the range of qos and delay values as above, so that you can compare them. Your Analyser will publish to the ‘request/qos’ and ‘request/delay’ topics to get the Publisher to deliver what you need at that time. For the QoS, subscribe at the same QoS as requested (i.e. if publisher->broker qos=2 then Analyser->broker should have qos=2 as well). The Analyser does not need to take all (6 delay * 3 qos) measurements in one run, but the closer in time the measurements occur the better, as network conditions do change all the time.

You can test all of these at home on your local broker. It is only in the final measurements that you will allow another student’s Analyser to access your broker, and vice-versa.
